<!DOCTYPE html>
<html lang="ja">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wiz Mapper</title>

    <style>
      :root {
	  --pal0: #FFFFFF;
	  --pal1: #FF0000;
	  --pal2: #00FF00;
	  --pal3: #0000FF;
	  --pal4: #FFFF00;
	  --pal5: #FF00FF;
	  --pal6: #00FFFF;
	  --pal7: #FFA500;
	  --pal8: #800080;
	  --pal9: #008000;
	  --pal10: #800000;
	  --pal11: #40E0D0;
	  --pal12: #FFC0CB;
	  --pal13: #A52A2A;
	  --pal14: #808080;
	  --pal15: transparent;
	  --bg-col: black;
      }
      body {
	  background: black;
	  color: white;
	  flex-direction: column;
	  min-height: 100vh;
	  font-family: sans-serif;
	  width: 64vw;
	  height: 92vh;
	  min-width: 600px;
	  min-height: 400px;
	  padding: 0px;
	  margin: 0px;
	  overflow: hidden;
      }
      p {  font-size: 0.7rem;      }

      #map-con {
	  background: transparent;
	  padding: 0px;
	  margin: 0px;
	  display: grid;
	  transform-origin: top left; /* パン操作の基準点を左上に設定 */
	  grid-template-columns: repeat(100, 1fr);
      }
      body.is-selecting-rect,
      body.is-selecting-rect .cell {
          cursor: crosshair !important;
      }

      .cell {
	  --cell-bg: transparent;	  
	  background-color: var(--cell-bg);
	  color: inherit;
	  position: relative;
	  width: 24px;
	  height: 24px;
	  cursor: pointer;
	  transition: border-color 0.1s ease-out, background-color 0.1s;
	  border: 1px dotted rgba(55, 55, 155, 0.5);
	  box-sizing: border-box;
	  z-index: 0px;
      }

      .cell.grid-line-col { border-right: 1px solid #448; }
      .cell.grid-line-row { border-bottom: 1px solid #448; }
      .cell.explored { border: 1px dotted #484; }
      .cell.explored.grid-line-col { border-right: 1px solid #444; }
      .cell.explored.grid-line-row { border-bottom: 1px solid #444; }

      .cell.selecting {
	  position: relative;
	  outline: 1px solid rgba(0, 220, 255, 0.1) !important;
	  z-index: 1;
	  cursor: grab;
      }

      .cell.selecting.grabbing,
      .cell.selecting.grabbing::before {
	  cursor: grabbing;
      }

      .cell.selecting::before {
	  content: '';
	  position: absolute;
	  inset: 0;
	  background-color: rgba(0, 170, 255, 0.2);
      }

      /* メモありセルに表示するインジケーター */
      .cell.has-memo::after {
	  content: '';
	  position: absolute;
	  top: 0;
	  right: 0;
	  width: 0;
	  height: 0;
	  border-style: solid;
	  border-width: 0 5px 5px 0;
	  border-color: transparent #f0f transparent transparent;
      }

      /* カスタムツールチップ */
      .tooltip {
	  position: fixed;
	  display: none;
	  padding: 4px 8px;
	  background-color: #222;
	  color: white;
	  border: 1px solid #888;
	  border-radius: 4px;
	  font-size: 0.8rem;
	  z-index: 1000;
	  pointer-events: none; /* ツールチップがマウスイベントを妨げないようにする */
      }
      .status {
	  display: block;
	  text-align: center;
	  height: 1.2rem;
	  font-size: 1rem;
	  border-radius: 0.25rem;
	  transition: opacity 0.3s;
	  opacity: 0;
	  user-select: none;
      }

      .pal-con {
	  position: fixed;
	  left: 2vh;
	  top: 2vh;
	  padding: 1.5rem 0.5rem 0.5rem;
	  background-color: rgba(155, 155, 155, 0.1);
	  backdrop-filter: blur(2px);
	  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
	  border-radius: 0.5rem;
	  /* rounded-lg */
	  border: 1px solid rgba(155, 155, 155, 1);
	  flex-shrink: 0;
	  width: 120px;
	  z-index: 50;
	  cursor: grab;
	  transition: box-shadow 0.1s;
      }
      .pal-con.grabbing {cursor: grabbing; }

      .grip-icon {
	  position: absolute;
	  top: 0rem;
	  right: 0.5rem;
	  padding: 0rem;
	  color: #9ca3af;
	  opacity: 0.8;
	  pointer-events: none;
      }

      .mark-col {
	  gap: 0.25rem;
	  box-shadow: 0 0 2px rgba(2, 2, 2, 1);
      }

      .col-btn {
	  width: 24px;
	  height: 24px;
	  margin: 1px;
	  border-radius: 0.2rem;
	  transition: transform 0.1s, box-shadow 0.1s;
	  cursor: pointer;
      }

      .col-btn:hover {
	  transform: scale(1.1);
	  box-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
      }

      .select-col {
	  transform: scale(0.9); /* 少し小さくして押された感を出す */
	  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.6); /* 内側に影を付けて押し込みを表現 */
      }

      /* 選択中のボタンはホバーしても拡大しないようにする */
      .select-col:hover {
	  transform: scale(0.9);
	  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.6);
      }

      .is-hidden {
	  opacity: 0;
	  pointer-events: none;
      }

      .loading-overlay {
	  position: absolute;
	  inset: 0;
	  background-color: black;
	  display: flex;
	  flex-direction: column;
	  align-items: center;
	  justify-content: center;
	  transition: opacity 0.3s;
      }

      .loading-text {
	  margin-top: 1rem;
	  font-size: 1.25rem;
      }

      .spinner {
	  border: 4px solid rgba(255, 255, 255, 0.3);
	  border-radius: 50%;
	  border-top: 4px solid #fff;
	  width: 40px;
	  height: 40px;
	  animation: spin 1s linear infinite;
      }

      @keyframes spin {
	  0% {
	      transform: rotate(0deg);
	  }

	  100% {
	      transform: rotate(360deg);
	  }
      }

      .menu {
	  display: flex;
	  flex-direction: column;
	  font-size: 0.8rem;
      }

      .menu .btn {
	  text-align: center;
	  font-size: 0.7rem;
	  background-color: rgba(7, 34, 59, 0.95);
	  color: white;
	  border: 1px solid rgba(175, 240, 390, 0.5);
	  transition: background-color 0.2s;
	  width: 95%;
	  height: 20px;
	  margin: 2px;
	  border-radius: 6px;
      }

      .btn:hover {
	  background-color: rgba(175, 240, 390, 0.5);
	  color: black;
	  box-shadow: 0 4px 12px rgba(143, 143, 143, 0.7);
	  cursor: pointer;
      }

      #name {
	  display: block;
	  position: fixed;
	  font-family: impact;
	  font-weight: bold;
	  font-size: 20rem;
	  color: #111;
	  top: 3px;
	  z-index: -9999;
      }
    </style>
    
  </head>
  <!--   https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js -->
  <script src="html2canvas.min.js"></script>  
  <body>
    <div id="name">Wiz Mapper</div>
    <div class="map-con" id="map-con"></div>
    <div id="status" class="status"></div>
    <div id="tooltip" class="tooltip"></div>
    <div id="pal-con" class="pal-con" title="draggable color pal">
      <div class="btn" id="pal"></div>
      <div class="grip-icon"> ⠿ </div>
      <div id="col-pal"></div>
      <hr>
      <div class="menu">
	<div class="btn" id="clr-sel">選択領域クリア</div>
	<div class="btn" id="clr-map">オールワイプ</div>
	<div class="btn" id="pip-btn">PIP(手前表示)</div>
	<div class="btn" id="reset-view-btn">位置リセット</div>
	<div class="btn" id="print-btn">印刷(試験的)</div>
	<hr>
	<div class="btn" id="export-btn">ファイルに保存</div>
	<div class="btn" id="import-btn">ファイルから読込</div>
	<input type="file" id="import-file-input" accept=".json" style="display: none;">
      </div>
    </div>
    <div id="loading-overlay" class="loading-overlay">
      <div class="spinner"></div>
      <p class="loading-text">Loading...</p>
    </div>

    <script type="module">
      const rootStyles = getComputedStyle(document.documentElement);
      const PAL = Array.from({ length: 16 }, (_, i) =>
	  rootStyles.getPropertyValue(`--pal${i}`).trim()
      );
      const BsCOL = 15; // base color index 
      const COL_MAP = PAL.reduce((a, c, i) => { a[i] = c; return a; }, {});
      const GrSZ = 100; // grid size
      const MEMO_KEY = 'wiz_mapper_memos';
      let memoData = new Map();
      const MAP_KEY = 'wiz_mapper';
      let mapState = new Uint8Array(GrSZ * GrSZ).fill(BsCOL);
      let mapCon = document.getElementById('map-con');
      let status = document.getElementById('status');
      const tooltip = document.getElementById('tooltip');
      let selCol = 0;
      const palCon = document.getElementById('pal-con');
      let isDrag = false;
      let dragOffX = 0;
      let dragOffY = 0;
      let inPal = false;
      let isDrawing = false; // 左ドラッグで描画中かどうかのフラグ

      let isSel = false; // 矩形選択中かどうかのフラグ
      let selStartIdx = null;  // 選択開始セルのインデックス
      let clipboard = { data: null, memos: null, width: 0, height: 0, TLIdx: null }; // コピーしたデータを保持
      let isSelActive = false; // 矩形選択が確定しているかどうかのフラグ
      let isMovSel = false; // 選択領域を移動中かどうかのフラグ
      let mvStartIdx = null; // 移動開始時の起点セルインデックス
      let srcIdx = null; // 移動する選択領域の元の左上インデックス
      let isPanning = false; // マップをパン（移動）中かどうかのフラグ
      let panStartX = 0;
      let panStartY = 0;
      let iniTrns = { x: 0, y: 0 };

      const clrMap = document.getElementById('clr-map');


      const showStatus = (message) => {
	  status.textContent = message;
	  status.className = `status`;
	  status.style.opacity = 1;
	  setTimeout(() => {
              status.style.opacity = 0;
	  }, 2000);
      };

      const saveMap = () => {
	  try {
              const mapString = Array.from(mapState).map(v => v.toString(16)).join('');
              localStorage.setItem(MAP_KEY, mapString);
	  } catch (error) {
              console.error("Local Storage save error:", error);
	      showStatus('保存中にエラーが発生しました');
	  }
      };

      const saveMemos = () => {
	  try {
	      const memoArray = Array.from(memoData.entries());
	      localStorage.setItem(MEMO_KEY, JSON.stringify(memoArray));
	  } catch (error) {
	      console.error("Local Storage save error (memos):", error);
	      showStatus('メモの保存中にエラーが発生しました');
	  }
      };


      const renderGrid = () => {
	  if (mapCon.children.length === 0) {
              mapCon.innerHTML = '';
              for (let i = 0; i < GrSZ * GrSZ; i++) {
		  const cell = document.createElement('div');
		  cell.classList.add('cell');
		  cell.dataset.idx = i;
		  const col = i % GrSZ;
		  if (col % 10 === 9 && col < GrSZ - 1) {
		      cell.classList.add('grid-line-col');
		  }
		  const row = Math.floor(i / GrSZ);
		  if (row % 10 === 9 && row < GrSZ - 1) {
		      cell.classList.add('grid-line-row');
		  }
		  mapCon.appendChild(cell);
              }
	  }
	  for (let i = 0; i < GrSZ * GrSZ; i++) {
              const cell = mapCon.children[i];
              const c = mapState[i];
              cell.style.setProperty('--cell-bg', COL_MAP[c]);
              if (c !== BsCOL) {
		  cell.classList.add('explored');
              } else {
		  cell.classList.remove('explored');
              }
	      if (memoData.has(i)) {
		  cell.classList.add('has-memo');		  
	      } else {
		  cell.classList.remove('has-memo');
	      }
	  }
      };

      const handleCell = (i, color = null) => {
	  mapState[i] = color !== null ? color : (mapState[i] === BsCOL ? selCol : BsCOL);
	  const cell = mapCon.children[i];
	  cell.style.setProperty('--cell-bg', COL_MAP[mapState[i]]);
	  cell.classList.toggle('explored', mapState[i] !== BsCOL);
      };

      const updateMemoOnCell = (i, text) => {
	  const cell = mapCon.children[i];
	  cell.classList.toggle('has-memo', !!text);
      };

      const createPal = () => {
	  const palDiv = document.getElementById('col-pal');
	  palDiv.innerHTML = `<div id="mark-col" class="mark-col"></div>`;
	  const markerColorsDiv = document.getElementById('mark-col');
	  PAL.forEach((c, i) => {
              const b = document.createElement('button');
              b.classList.add('col-btn');
              b.style.backgroundColor = c;
              b.dataset.colorIdx = i;

              if (i === selCol)
		  b.classList.add('select-col');

              b.addEventListener('click', () => {
		  inPal = true;
		  document.querySelector('.select-col')?.classList.remove('select-col');
		  selCol = i;
		  b.classList.add('select-col');
              });
              markerColorsDiv.appendChild(b);
	  });
      };

      /**
       * 指定した位置とサイズで矩形選択のハイライトを描画する関数
       * @param {number} TLIdx - 描画開始位置（左上）のインデックス
       * @param {number} width - 矩形の幅
       * @param {number} height - 矩形の高さ
       */
      const drawSelHighLight = (TLIdx, width, height) => {
	  document.querySelectorAll('.cell.selecting').forEach(c => c.classList.remove('selecting'));
	  if (TLIdx === null) return;
	  const startCol = TLIdx % GrSZ;
	  const startRow = Math.floor(TLIdx / GrSZ);
	  for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
		  const index = (startRow + y) * GrSZ + (startCol + x);
		  mapCon.children[index]?.classList.add('selecting');
	      }
	  }
      };
      /**
       * 矩形選択のハイライトを更新する関数
       */
      const updateSelectionHighlight = (endIdx) => {
	  document.querySelectorAll('.cell.selecting').forEach(c => c.classList.remove('selecting'));
	  if (selStartIdx === null || endIdx === null) return;
	  const startCol = selStartIdx % GrSZ;
	  const startRow = Math.floor(selStartIdx / GrSZ);
	  const endCol = endIdx % GrSZ;
	  const endRow = Math.floor(endIdx / GrSZ);
	  const minCol = Math.min(startCol, endCol);
	  const maxCol = Math.max(startCol, endCol);
	  const minRow = Math.min(startRow, endRow);
	  const maxRow = Math.max(startRow, endRow);
	  drawSelHighLight(minRow * GrSZ + minCol, maxCol - minCol + 1, maxRow - minRow + 1);
      };

      /**
       * 選択範囲のデータをクリップボード用変数にコピーする関数
       */
      const copySelData = (endIdx) => {
	  if (selStartIdx === null || endIdx === null) return;
	  const startCol = selStartIdx % GrSZ;
	  const startRow = Math.floor(selStartIdx / GrSZ);
	  const endCol = endIdx % GrSZ;
	  const endRow = Math.floor(endIdx / GrSZ);
	  const minCol = Math.min(startCol, endCol);
	  const maxCol = Math.max(startCol, endCol);
	  const minRow = Math.min(startRow, endRow);
	  const TLIdx = minRow * GrSZ + minCol;
	  const maxRow = Math.max(startRow, endRow);
	  const memos = new Map();
	  const width = maxCol - minCol + 1;
	  const height = maxRow - minRow + 1;
	  const data = [];
	  for (let y = 0; y < height; y++) {
              const rowData = new Uint8Array(width);
	      for (let x = 0; x < width; x++) {
		  const index = (minRow + y) * GrSZ + (minCol + x);
		  rowData[x] = mapState[index];
		  if (memoData.has(index)) {
		      memos.set(index, memoData.get(index));
		  }
	      }
	      data.push(rowData);		  
	  }
	  clipboard = { data, memos, width, height, TLIdx };
	  showStatus(`${width}x${height} の範囲をコピーしました`);
	  console.log("Copied to clipboard:", clipboard); // デバッグ用にコンソールに出力
      };
      /**
       * 指定した位置にクリップボードの内容を貼り付ける（ペーストする）関数
       * @param {number} TLIdx - 貼り付け先の左上インデックス
       */
      const pasteClipboard = (idx) => {
	  if (!clipboard.data) return;
	  const { data, memos, width, height } = clipboard;
	  const Col = idx % GrSZ;
	  const Row = Math.floor(idx / GrSZ);
	  if (srcIdx !== null) {
	      const orgC = srcIdx % GrSZ;
	      const orgR = Math.floor(srcIdx / GrSZ);
	      for (let y = 0; y < height; y++) {
		  for (let x = 0; x < width; x++) {
		      const orgId = (orgR + y) * GrSZ + (orgC + x);
		      handleCell(orgId, BsCOL);
		      // 移動元のメモを削除
		      if (memoData.has(orgId)) {
			  memoData.delete(orgId);
			  updateMemoOnCell(orgId, null);
		      }
		  }
	      }
	  }
	  // 新しい位置にメモを移動
	  memos.forEach((memoText, originalIndex) => {
	      const delta = originalIndex - srcIdx;
	      const newIndex = idx + delta;
	      memoData.set(newIndex, memoText);
	      updateMemoOnCell(newIndex, memoText);
	  });
	  for (let y = 0; y < height; y++) {
	      for (let x = 0; x < width; x++) {
		  const mapIdx = (Row + y) * GrSZ + (Col + x);
                  handleCell(mapIdx, data[y][x]);
	      }
	  }
	  saveMap();
	  saveMemos();
	  showStatus(`${width}x${height} の範囲を移動しました`);
      };
      

      /**
       * 選択領域をクリアする関数
       */
      const clearSelection = () => {
	  document.querySelectorAll('.cell.selecting').forEach(c => c.classList.remove('selecting'));
	  isSelActive = false;
	  selStartIdx = null;
          clipboard = { data: null, memos: null, width: 0, height: 0, TLIdx: null };
      };
      const loadMemos = () => {
	  const memoString = localStorage.getItem(MEMO_KEY);
	  if (memoString) {
	      try {
		  memoData = new Map(JSON.parse(memoString));
	      } catch (e) {
		  console.error("Failed to parse memos:", e);
		  memoData = new Map();
	      }
	  }
      };
      const loadMap = () => {
	  const mapString = localStorage.getItem(MAP_KEY);
	  if (mapString && mapString.length === GrSZ * GrSZ) {
              for (let i = 0; i < mapState.length; i++) {
		  mapState[i] = parseInt(mapString[i], 16);
              }
              showStatus('Loaded Map form Your Browser(Local Strage ).', MAP_KEY);
	  } else {
              showStatus('Created New map.');
              mapState.fill(BsCOL);
	  }
	  loadMemos();
	  renderGrid();
	  document.getElementById('loading-overlay').classList.add('is-hidden');
	  
      };
      
      mapCon.addEventListener('mousedown', (e) => {
	  const cell = e.target.closest('.cell');

	  // 中ボタン、または左右同時押しでのパン操作開始
	  if (e.button === 1 || e.buttons === 3) {
	      e.preventDefault();
	      isPanning = true;
	      panStartX = e.clientX;
	      panStartY = e.clientY;
	      
	      const currentTransform = new DOMMatrix(getComputedStyle(mapCon).transform);
	      iniTrns.x = currentTransform.m41;
	      iniTrns.y = currentTransform.m42;
	      
	      mapCon.style.cursor = 'grabbing';
	      return;
	  }

	  if (!cell || inPal) return;

	  // 選択領域外での左クリックで選択解除
	  if (isSelActive && !cell.classList.contains('selecting') && e.button === 0) {
              clearSelection();
	  }

	  if (e.button === 0) { // 左クリック
	      if (e.shiftKey) { // Shift + 左クリックでメモ編集
		  e.preventDefault();
		  const i = parseInt(cell.dataset.idx, 10);
		  const currentMemo = memoData.get(i) || '';
		  const newMemo = prompt('メモを入力してください:', currentMemo);

		  if (newMemo !== null) { // キャンセルされなかった場合
		      if (newMemo) {
			  memoData.set(i, newMemo);
		      } else {
			  memoData.delete(i);
		      }
		      updateMemoOnCell(i, newMemo);
		      saveMemos();
		  }
	      } else if (cell.classList.contains('selecting')) {
		  // 選択領域内の左クリック: ドラッグ移動を開始
		  e.preventDefault();
		  isMovSel = true;
		  mvStartIdx = parseInt(cell.dataset.idx, 10);

		  // 移動元の左上インデックスを計算して保持
		  const selectedCells = document.querySelectorAll('.cell.selecting');
		  srcIdx = Array.from(selectedCells).reduce((min, c) => Math.min(min, parseInt(c.dataset.idx, 10)), Infinity);
		  selectedCells.forEach(c => c.classList.add('grabbing'));

              } else {
		  // 通常のセルクリック
		  isDrawing = true;
		  const i = parseInt(cell.dataset.idx, 10);
		  handleCell(i);
              }
	  } else if (e.button === 2) { // 右クリック
              e.preventDefault();
              // 既存の選択をクリアして新しい選択を開始
              clearSelection();
              isSel = true;
              document.body.classList.add('is-selecting-rect');
              isSelActive = true;
              selStartIdx = parseInt(cell.dataset.idx, 10);
              updateSelectionHighlight(selStartIdx);
	  }
      });

      mapCon.addEventListener('mouseover', (e) => {
	  // パン中は他のマウスオーバー処理を中断
	  if (isPanning) {
	      // isPanningがtrueでも、ボタンが離されている場合があるためチェック
	      if (e.buttons !== 4 && e.buttons !== 3) { // 4=中ボタン, 3=左右ボタン
		  isPanning = false;
		  mapCon.style.cursor = '';
	      }
	  }
	  const cell = e.target.closest('.cell');
	  if (!cell) return;

	  if (isDrawing) { // 左ドラッグ描画中の処理
	      const i = parseInt(cell.dataset.idx, 10);
	      handleCell(i);
	  }
	  // メモのツールチップ表示
	  if (cell.classList.contains('has-memo')) {
	      const i = parseInt(cell.dataset.idx, 10);
	      const memoText = memoData.get(i);
	      if (memoText) {
		  tooltip.textContent = memoText;
		  tooltip.style.display = 'block';
	      }
	  } else {
	      tooltip.style.display = 'none';
	  }


	  if (isSel) { // 矩形選択中のハイライト更新
              const i = parseInt(cell.dataset.idx, 10);
              updateSelectionHighlight(i);
	  } else if (isMovSel) { // 選択領域の移動中のハイライト更新
	      const i = parseInt(cell.dataset.idx, 10);
	      const sRow = Math.floor(mvStartIdx / GrSZ);
	      const sCol = mvStartIdx % GrSZ;
	      const row = Math.floor(i / GrSZ);
	      const col = i % GrSZ;
	      const dRow = row - sRow;
	      const dCol = col - sCol;
	      const newTL = srcIdx + dRow * GrSZ + dCol;
	      drawSelHighLight(newTL, clipboard.width, clipboard.height);
	  }
      });

      const handleMouseUp = (e) => {
	  if (isDrag) {
	      isDrag = false;
	      palCon.classList.remove('grabbing');
	  }
	  if (isPanning) {
	      isPanning = false;
	      mapCon.style.cursor = '';
	  }
	  if (isDrawing) {
	      isDrawing = false;
	      saveMap(); // 描画が終わったら保存
	      showStatus('マップを保存しました');
	  }
	  if (isMovSel) {
	      const cell = e.target.closest('.cell');
	      if (cell) {
		  const eIdx = parseInt(cell.dataset.idx, 10);
		  const sRow = Math.floor(mvStartIdx / GrSZ);
		  const sCol = mvStartIdx % GrSZ;
		  const eRow = Math.floor(eIdx / GrSZ);
		  const eCol = eIdx % GrSZ;
		  const dRow = eRow - sRow;
		  const dCol = eCol - sCol;
		  const pasteIdx = srcIdx + dRow * GrSZ + dCol;
		  pasteClipboard(pasteIdx); // 貼り付けを実行
		  clearSelection(); // 選択範囲とクリップボードをクリア
	      }
	      isMovSel = false;
	      mvStartIdx = null;
	      srcIdx = null; // 移動元の情報をクリア
	  }
	  document.querySelectorAll('.cell.grabbing').forEach(c => c.classList.remove('grabbing'));
	  inPal = false;
	  if (isSel && e.button === 2) {          // 矩形選択の終了処理
	      const cell = e.target.closest('.cell');
	      if (cell) {
		  const endIdx = parseInt(cell.dataset.idx, 10);
		  copySelData(endIdx);
	      }
	      isSel = false;
	      document.body.classList.remove('is-selecting-rect');
	  }
      };
      
      const handleMouseMove = (e) => {
	  // パン操作中のマップ移動
	  if (isPanning) {
	      const dx = e.clientX - panStartX;
	      const dy = e.clientY - panStartY;
	      mapCon.style.transform = `translate(${iniTrns.x + dx}px, ${iniTrns.y + dy}px)`;
	      return;
	  }

	  // パレット移動
	  if (isDrag) {
	      let newX = e.clientX - dragOffX;
	      let newY = e.clientY - dragOffY;
	      const maxX = window.innerWidth - palCon.offsetWidth;
	      const maxY = window.innerHeight - palCon.offsetHeight;
	      newX = Math.max(0, Math.min(newX, maxX));
	      newY = Math.max(0, Math.min(newY, maxY));
	      palCon.style.left = `${newX}px`;
	      palCon.style.top = `${newY}px`;
	  }

	  // ツールチップの位置を更新
	  if (tooltip.style.display === 'block') {
	      tooltip.style.left = `${e.clientX + 15}px`;
	      tooltip.style.top = `${e.clientY + 15}px`;
	  }
      };

      document.addEventListener('mouseup', handleMouseUp);
      document.addEventListener('mousemove', handleMouseMove);

      const resetViewBtn = document.getElementById('reset-view-btn');
      resetViewBtn.addEventListener('click', () => {
	  // CSSのtransformを初期値に戻す
	  mapCon.style.transform = 'translate(0px, 0px)';
	  // パン操作の状態もリセット
	  iniTrns.x = 0;
	  iniTrns.y = 0;
	  showStatus('表示位置をリセットしました');
      });

      const printBtn = document.getElementById('print-btn');
      printBtn.addEventListener('click', () => {
	  showStatus('マップを画像に変換しています...');
	  // html2canvas を使って #map-con を画像化
	  html2canvas(mapCon, {
	      backgroundColor: getComputedStyle(document.body).backgroundColor // 背景色を指定
	  }).then(canvas => {
	      const printWindow = window.open('', '_blank');
	      printWindow.document.write(`
		  <!DOCTYPE html>
		  <html>
		  <head><title>マップの印刷</title></head>
		  <body style="margin:0;">
		      <img src="${canvas.toDataURL('image/png')}" style="width:100%;">
		  </body>
		  </html>
	      `);
	      printWindow.document.close();
	      printWindow.onload = () => { printWindow.print(); };
	  });
      });

      clrMap.addEventListener('click', () => {
	  if (confirm('\n ┌○┐\n │ ワ│ハ_ハ\n │ イ│ ﾟωﾟ )　　　　　　　マップとメモを全て消去します\n │ プ│ ／  | 　　　　　　　この操作は元に戻せません\n └○┘   (⌒)\n        し⌒  ￣\n')) {
              mapState.fill(BsCOL);
	      memoData.clear();
              renderGrid();
              saveMap(); 
	      saveMemos();
              showStatus('マップとメモをリセットしました');
	  }
      });

      palCon.addEventListener('mousedown', (e) => {
	  if (e.target.closest('button')) {
              inPal = true;
              e.stopPropagation();
              return;
	  }
	  isDrag = true;
	  palCon.classList.add('grabbing');
	  const rect = palCon.getBoundingClientRect();
	  dragOffX = e.clientX - rect.left;
	  dragOffY = e.clientY - rect.top;
	  e.preventDefault();
      });

      window.addEventListener('resize', () => {
	  const rect = palCon.getBoundingClientRect();
	  let newX = rect.left;
	  let newY = rect.top;
	  const maxX = window.innerWidth - palCon.offsetWidth;
	  const maxY = window.innerHeight - palCon.offsetHeight;
	  newX = Math.max(0, Math.min(newX, maxX));
	  newY = Math.max(0, Math.min(newY, maxY));
	  palCon.style.left = `${newX}px`;
	  palCon.style.top = `${newY}px`;
      });

      // 選択領域クリアボタンの処理
      document.getElementById('clr-sel').addEventListener('click', () => {
	  if (clipboard.TLIdx !== null) { // 選択範囲がある場合のみ実行
	      const { TLIdx, width, height } = clipboard;
	      const sCol = TLIdx % GrSZ;
	      const sRow = Math.floor(TLIdx / GrSZ);
	      for (let y = 0; y < height; y++) {
		  for (let x = 0; x < width; x++) {
		      handleCell((sRow + y) * GrSZ + (sCol + x), BsCOL);
		  }
	      }
	      saveMap();
	      clearSelection();
	  }
      });

      // --- エクスポート/インポート機能 ---
      const exportBtn = document.getElementById('export-btn');
      exportBtn.addEventListener('click', () => {
	  const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:T]/g, '');
	  const defaultFilename = `wiz-mapper-data_${timestamp}.json`;
	  const filename = prompt('ファイル名を入力してください:', defaultFilename);

	  if (filename) {
	      try {
		  const dataToExport = {
		      mapData: Array.from(mapState),
		      memoData: Array.from(memoData.entries()),
		  };
		  const jsonString = JSON.stringify(dataToExport, null, 2);
		  const blob = new Blob([jsonString], { type: 'application/json' });
		  const url = URL.createObjectURL(blob);
		  const a = document.createElement('a');
		  a.href = url;
		  a.download = filename.endsWith('.json') ? filename : `${filename}.json`;
		  document.body.appendChild(a);
		  a.click();
		  document.body.removeChild(a);
		  URL.revokeObjectURL(url);
		  showStatus('データをファイルに保存しました');
	      } catch (error) {
		  console.error("Export failed:", error);
		  showStatus('エクスポート中にエラーが発生しました');
	      }
	  }
      });

      const importBtn = document.getElementById('import-btn');
      const importFileInput = document.getElementById('import-file-input');
      importBtn.addEventListener('click', () => importFileInput.click());
      importFileInput.addEventListener('change', (event) => {
	  const file = event.target.files[0];
	  if (!file) return;
	  const reader = new FileReader();
	  reader.onload = (e) => {
	      try {
		  const data = JSON.parse(e.target.result);
		  if (data.mapData && data.mapData.length === GrSZ * GrSZ && data.memoData) {
		      mapState = new Uint8Array(data.mapData);
		      memoData = new Map(data.memoData);
		      renderGrid();
		      saveMap();
		      saveMemos();
		      showStatus('ファイルからデータを読み込みました');
		  } else { throw new Error('Invalid data format'); }
	      } catch (error) { showStatus('ファイルの読み込みに失敗しました'); }
	  };
	  reader.readAsText(file);
	  importFileInput.value = ''; // 同じファイルを再度選択できるようにリセット
      });

      (() => {
	  createPal();
	  loadMap();
	  loadMemos();
      })();

      // ブラウザの右クリックメニューを無効化
      mapCon.addEventListener('contextmenu', (e) => e.preventDefault());

      // --- Picture-in-Picture 機能 ---
      const pipButton = document.getElementById('pip-btn');
      let pipWindow = null;

      pipButton.addEventListener('click', async () => {
	  if (!window.documentPictureInPicture) {
	      showStatus('お使いのブラウザはこの機能に未対応です');
	      return;
	  }
	  try {
	      pipWindow = await window.documentPictureInPicture.requestWindow({
		  width: mapCon.clientWidth,
		  height: mapCon.clientHeight,
	      });

	      // PiPウィンドウにタイトルを設定
	      const pipTitle = document.createElement('title');
	      pipTitle.textContent = 'Wiz Mapper - Map View';
	      pipWindow.document.head.appendChild(pipTitle);

	      [...document.styleSheets].forEach((styleSheet) => {
		  const cssRules = [...styleSheet.cssRules].map((rule) => rule.cssText).join('');
		  const style = document.createElement('style');
		  style.textContent = cssRules;
		  pipWindow.document.head.appendChild(style);
	      });
	      pipWindow.document.body.append(mapCon);
	      pipWindow.document.addEventListener('mouseup', handleMouseUp);
	      pipWindow.document.addEventListener('mousemove', handleMouseMove);
	      pipWindow.addEventListener('pagehide', (event) => {
		  document.body.insertBefore(mapCon, document.getElementById('status'));
		  pipWindow = null;
	      });
	  } catch (error) {
	      console.error('Picture-in-Picture Error:', error);
	  }
      });
    </script>
  </body>
</html>
