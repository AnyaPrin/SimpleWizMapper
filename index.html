<!DOCTYPE html>
<html lang="ja">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wiz Mapper</title>
    <!-- Favicon: 鉛筆の絵文字をSVGとして使用 -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>✏️</text></svg>">

    <style>
      :root {
	  --pal0: #FFFFFF;
	  --pal1: #FF0000;
	  --pal2: #00FF00;
	  --pal3: #0000FF;
	  --pal4: #FFFF00;
	  --pal5: #FF00FF;
	  --pal6: #00FFFF;
	  --pal7: #FFA500;
	  --pal8: #800080;
	  --pal9: #008000;
	  --pal10: #800000;
	  --pal11: #40E0D0;
	  --pal12: #FFC0CB;
	  --pal13: #A52A2A;
	  --pal14: #808080;
	  --pal15: transparent;
	  --bg-col: black;
      }
      body {
	  background: black;
	  color: white;
	  flex-direction: column;
	  min-height: 100vh;
	  font-family: sans-serif;
	  width: 64vw;
	  height: 92vh;
	  min-width: 600px;
	  min-height: 400px;
	  padding: 0px;
	  margin: 0px;
	  overflow: hidden;
      }
      p {  font-size: 0.7rem;      }

      #map-con {
	  background: transparent;
	  padding: 0px;
	  margin: 0px;
	  display: grid;
	  transform-origin: top left; /* パン操作の基準点を左上に設定 */
	  grid-template-columns: repeat(100, 1fr);
      }
      body.is-selecting-rect,
      body.is-selecting-rect .cell {
          cursor: crosshair !important;
      }

      .cell {
	  --cell-bg: transparent;	  
	  background-color: var(--cell-bg);
	  color: inherit;
	  position: relative;
	  width: 24px;
	  height: 24px;
	  cursor: pointer;
	  transition: border-color 0.1s ease-out, background-color 0.1s;
	  border: 1px dotted rgba(55, 55, 155, 0.5);
	  box-sizing: border-box;
	  z-index: 0px;
      }

      .cell.grid-line-col { border-right: 1px solid #448; }
      .cell.grid-line-row { border-bottom: 1px solid #448; }
      .cell.explored { border: 1px dotted #484; }
      .cell.explored.grid-line-col { border-right: 1px solid #444; }
      .cell.explored.grid-line-row { border-bottom: 1px solid #444; }

      .cell.selecting {
	  position: relative;
	  outline: 1px solid rgba(0, 220, 255, 0.1) !important;
	  z-index: 1;
	  cursor: grab;
      }

      .cell.selecting.grabbing,
      .cell.selecting.grabbing::before {
	  cursor: grabbing;
      }

      .cell.selecting::before {
	  content: '';
	  position: absolute;
	  inset: 0;
	  background-color: rgba(0, 170, 255, 0.2);
      }

      /* メモありセルに表示するインジケーター */
      .cell.has-memo::after {
	  content: '';
	  position: absolute;
	  top: 0;
	  right: 0;
	  width: 0;
	  height: 0;
	  border-style: solid;
	  border-width: 0 5px 5px 0;
	  border-color: transparent #f0f transparent transparent;
      }

      /* カスタムツールチップ */
      .tooltip {
	  position: fixed;
	  display: none;
	  padding: 4px 8px;
	  background-color: #222;
	  color: white;
	  border: 1px solid #888;
	  border-radius: 4px;
	  font-size: 0.8rem;
	  z-index: 1000;
	  pointer-events: none; /* ツールチップがマウスイベントを妨げないようにする */
      }
      .status {
	  display: block;
	  text-align: center;
	  height: 1.2rem;
	  font-size: 1rem;
	  border-radius: 0.25rem;
	  transition: opacity 0.3s;
	  opacity: 0;
	  user-select: none;
      }

      .pal-con {
	  position: fixed;
	  left: 2vh;
	  top: 2vh;
	  padding: 1.5rem 0.5rem 0.5rem;
	  background-color: rgba(155, 155, 155, 0.1);
	  backdrop-filter: blur(2px);
	  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
	  border-radius: 0.5rem;
	  /* rounded-lg */
	  border: 1px solid rgba(155, 155, 155, 1);
	  flex-shrink: 0;
	  width: 120px;
	  z-index: 50;
	  cursor: grab;
	  transition: box-shadow 0.1s;
      }
      .pal-con.grabbing {cursor: grabbing; }

      .grip-icon {
	  position: absolute;
	  top: 0rem;
	  right: 0.5rem;
	  padding: 0rem;
	  color: #9ca3af;
	  opacity: 0.8;
	  pointer-events: none;
      }

      .mark-col {
	  gap: 0.25rem;
	  box-shadow: 0 0 2px rgba(2, 2, 2, 1);
      }

      .col-btn {
	  width: 24px;
	  height: 24px;
	  margin: 1px;
	  border-radius: 0.2rem;
	  transition: transform 0.1s, box-shadow 0.1s;
	  cursor: pointer;
      }

      .col-btn:hover {
	  transform: scale(1.1);
	  box-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
      }

      .select-col {
	  transform: scale(0.9); /* 少し小さくして押された感を出す */
	  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.6); /* 内側に影を付けて押し込みを表現 */
      }

      /* 選択中のボタンはホバーしても拡大しないようにする */
      .select-col:hover {
	  transform: scale(0.9);
	  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.6);
      }

      .is-hidden {
	  opacity: 0;
	  pointer-events: none;
      }

      .loading-overlay {
	  position: absolute;
	  inset: 0;
	  background-color: black;
	  display: flex;
	  flex-direction: column;
	  align-items: center;
	  justify-content: center;
	  transition: opacity 0.3s;
      }

      .loading-text {
	  margin-top: 1rem;
	  font-size: 1.25rem;
      }

      .spinner {
	  border: 4px solid rgba(255, 255, 255, 0.3);
	  border-radius: 50%;
	  border-top: 4px solid #fff;
	  width: 40px;
	  height: 40px;
	  animation: spin 1s linear infinite;
      }

      @keyframes spin {
	  0% {
	      transform: rotate(0deg);
	  }

	  100% {
	      transform: rotate(360deg);
	  }
      }

      .menu {
	  display: flex;
	  flex-direction: column;
	  font-size: 0.8rem;
      }

      .menu .btn {
	  text-align: center;
	  font-size: 0.7rem;
	  background-color: rgba(7, 34, 59, 0.95);
	  color: white;
	  border: 1px solid rgba(175, 240, 390, 0.5);
	  transition: background-color 0.2s;
	  width: 95%;
	  height: 20px;
	  margin: 2px;
	  border-radius: 6px;
      }

      .btn:hover {
	  background-color: rgba(175, 240, 390, 0.5);
	  color: black;
	  box-shadow: 0 4px 12px rgba(143, 143, 143, 0.7);
	  cursor: pointer;
      }

      #name {
	  display: block;
	  position: fixed;
	  font-family: impact;
	  font-weight: bold;
	  font-size: 20rem;
	  color: #111;
	  top: 3px;
	  z-index: -9999;
      }
    </style>
    
  </head>
  <!--   https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js -->
  <script src="html2canvas.min.js"></script>  
  <body>
    <div id="name">Wiz Mapper</div>
    <div class="map-con" id="map-con"></div>
    <div id="status" class="status"></div>
    <div id="tooltip" class="tooltip"></div>
    <div id="pal-con" class="pal-con" title="draggable color pal">
      <div class="btn" id="pal"></div>
      <div class="grip-icon"> ⠿ </div>
      <div id="col-pal"></div>
      <hr>
      <div class="menu">
	<div class="btn" id="clr-sel">クリア</div>
	<div class="btn" id="fill-sel">塗りつぶし</div>
	<hr>	
	<div class="btn" id="pip-btn">ミニマップ</div>
	<div class="btn" id="reset-view-btn">位置リセット</div>
	<hr>
	<div class="btn" id="export-btn">ファイル保存</div>
	<div class="btn" id="import-btn">ファイル読込</div>
	<hr>
	<div class="btn" id="help-btn">ヘルプ</div>
	<input type="file" id="import-file-input" accept=".json" style="display: none;">
	<div class="btn" id="clr-map">オールワイプ</div>
	<div class="btn" id="print-btn">印刷(試験的)</div>	
      </div>
    </div>
    <div id="loading-overlay" class="loading-overlay">
      <div class="spinner"></div>
      <p class="loading-text">Loading...</p>
    </div>

    <script type="module">
      // --- 設定値 ---
      const config = {
	  GRID_SIZE: 100,
	  BASE_COLOR_INDEX: 15,
	  LOCAL_STORAGE_MAP_KEY: 'wiz_mapper',
	  LOCAL_STORAGE_MEMO_KEY: 'wiz_mapper_memos',
	  PALETTE: Array.from({ length: 16 }, (_, i) => getComputedStyle(document.documentElement).getPropertyValue(`--pal${i}`).trim()),
	  get COLOR_MAP() { return this.PALETTE.reduce((a, c, i) => { a[i] = c; return a; }, {}); }
      };

      // --- UI要素 ---
      const ui = {
	  mapContainer: document.getElementById('map-con'),
	  status: document.getElementById('status'),
	  tooltip: document.getElementById('tooltip'),
	  paletteContainer: document.getElementById('pal-con'),
	  clearMapBtn: document.getElementById('clr-map'),
	  importFileInput: document.getElementById('import-file-input'),
	  loadingOverlay: document.getElementById('loading-overlay'),
      };

      // --- アプリケーションの状態 ---
      const state = {
	  map: new Uint8Array(config.GRID_SIZE * config.GRID_SIZE).fill(config.BASE_COLOR_INDEX),
	  memos: new Map(),
	  selectedColor: 0,
	  clipboard: { data: null, memos: null, width: 0, height: 0, TLIdx: null },
	  isDrawing: false,
	  isSelecting: false,
	  isSelectionActive: false,
	  isMovingSelection: false,
	  isPanning: false,
	  selectionStartIndex: null,
	  moveStartIndex: null,
	  sourceIndex: null,
	  panStart: { x: 0, y: 0 },
	  initialTransform: { x: 0, y: 0 },
      };

      // --- パレットドラッグ関連 ---
      let isDrag = false;
      let dragOffX = 0;
      let dragOffY = 0;
      let inPal = false;

      // --- サウンド関連 ---
      const clickSound = new Audio('click.wav');
      const playClick = () => {
	  // play()はユーザー操作起因でないと失敗することがあるため、念のためcatchを追加
	  clickSound.currentTime = 0; // 連打しても音が鳴るように再生位置をリセット
	  clickSound.play().catch(e => { /* console.error("Audio play failed:", e) */ });
      };


      const showStatus = (message) => {
	  ui.status.textContent = message;
	  ui.status.className = `status`;
	  ui.status.style.opacity = 1;
	  setTimeout(() => {
              ui.status.style.opacity = 0;
	  }, 2000);
      };

      const saveMap = () => {
	  try { // Use state.map and config constants
              const mapString = Array.from(state.map).map(v => v.toString(16)).join('');
              localStorage.setItem(config.LOCAL_STORAGE_MAP_KEY, mapString);
	  } catch (error) {
              console.error("Local Storage save error:", error);
	      showStatus('保存中にエラーが発生しました');
	  }
      };

      const saveMemos = () => {
	  try {
	      const memoArray = Array.from(state.memos.entries());
	      localStorage.setItem(config.LOCAL_STORAGE_MEMO_KEY, JSON.stringify(memoArray));
	  } catch (error) {
	      console.error("Local Storage save error (memos):", error);
	      showStatus('メモの保存中にエラーが発生しました');
	  }
      };


      const renderGrid = () => {
	  if (ui.mapContainer.children.length === 0) {
              ui.mapContainer.innerHTML = '';
              for (let i = 0; i < config.GRID_SIZE * config.GRID_SIZE; i++) {
		  const cell = document.createElement('div');
		  cell.classList.add('cell');
		  cell.dataset.idx = i;
		  const col = i % config.GRID_SIZE;
		  if (col % 10 === 9 && col < config.GRID_SIZE - 1) {
		      cell.classList.add('grid-line-col');
		  }
		  const row = Math.floor(i / config.GRID_SIZE);
		  if (row % 10 === 9 && row < config.GRID_SIZE - 1) {
		      cell.classList.add('grid-line-row');
		  }
		  ui.mapContainer.appendChild(cell);
              }
	  }
	  for (let i = 0; i < config.GRID_SIZE * config.GRID_SIZE; i++) {
              const cell = ui.mapContainer.children[i];
              const c = state.map[i];
              cell.style.setProperty('--cell-bg', config.COLOR_MAP[c]);
              if (c !== config.BASE_COLOR_INDEX) {
		  cell.classList.add('explored');
              } else {
		  cell.classList.remove('explored');
              }
	      if (state.memos.has(i)) {
		  cell.classList.add('has-memo');		  
	      } else {
		  cell.classList.remove('has-memo');
	      }
	  }
      };

      const handleCell = (i, color = null) => {
	  state.map[i] = color !== null ? color : (state.map[i] === config.BASE_COLOR_INDEX ? state.selectedColor : config.BASE_COLOR_INDEX);
	  const cell = ui.mapContainer.children[i];
	  cell.style.setProperty('--cell-bg', config.COLOR_MAP[state.map[i]]);
	  cell.classList.toggle('explored', state.map[i] !== config.BASE_COLOR_INDEX);
      };

      const updateMemoOnCell = (i, text) => {
	  const cell = ui.mapContainer.children[i];
	  cell.classList.toggle('has-memo', !!text);
      };

      const createPal = () => {
	  const palDiv = document.getElementById('col-pal');
	  palDiv.innerHTML = `<div id="mark-col" class="mark-col"></div>`;
	  const markerColorsDiv = document.getElementById('mark-col');
	  config.PALETTE.forEach((c, i) => {
              const b = document.createElement('button');
              b.classList.add('col-btn');
              b.style.backgroundColor = c;
              b.dataset.colorIdx = i;

              if (i === state.selectedColor)
		  b.classList.add('select-col');

              b.addEventListener('click', () => {
		  inPal = true;
		  document.querySelector('.select-col')?.classList.remove('select-col');
		  state.selectedColor = i;
		  b.classList.add('select-col');
		  playClick();
              });
              markerColorsDiv.appendChild(b);
	  });
      };

      /**
       * 指定した位置とサイズで矩形選択のハイライトを描画する関数
       * @param {number} TLIdx - 描画開始位置（左上）のインデックス
       * @param {number} width - 矩形の幅
       * @param {number} height - 矩形の高さ
       */
      const drawSelHighLight = (TLIdx, width, height) => {
	  document.querySelectorAll('.cell.selecting').forEach(c => c.classList.remove('selecting'));
	  if (TLIdx === null) return;
	  const startCol = TLIdx % config.GRID_SIZE;
	  const startRow = Math.floor(TLIdx / config.GRID_SIZE);
	  for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
		  const index = (startRow + y) * config.GRID_SIZE + (startCol + x);
		  ui.mapContainer.children[index]?.classList.add('selecting');
	      }
	  }
      };
      /**
       * 矩形選択のハイライトを更新する関数
       */
      const updateSelectionHighlight = (endIdx) => {
	  document.querySelectorAll('.cell.selecting').forEach(c => c.classList.remove('selecting'));
	  if (state.selectionStartIndex === null || endIdx === null) return;
	  const startCol = state.selectionStartIndex % config.GRID_SIZE;
	  const startRow = Math.floor(state.selectionStartIndex / config.GRID_SIZE);
	  const endCol = endIdx % config.GRID_SIZE;
	  const endRow = Math.floor(endIdx / config.GRID_SIZE);
	  const minCol = Math.min(startCol, endCol);
	  const maxCol = Math.max(startCol, endCol);
	  const minRow = Math.min(startRow, endRow);
	  const maxRow = Math.max(startRow, endRow);
	  drawSelHighLight(minRow * config.GRID_SIZE + minCol, maxCol - minCol + 1, maxRow - minRow + 1);
      };

      /**
       * 選択範囲のデータをクリップボード用変数にコピーする関数
       */
      const copySelData = (endIdx) => {
	  if (state.selectionStartIndex === null || endIdx === null) return;
	  const startCol = state.selectionStartIndex % config.GRID_SIZE;
	  const startRow = Math.floor(state.selectionStartIndex / config.GRID_SIZE);
	  const endCol = endIdx % config.GRID_SIZE;
	  const endRow = Math.floor(endIdx / config.GRID_SIZE);
	  const minCol = Math.min(startCol, endCol);
	  const maxCol = Math.max(startCol, endCol);
	  const minRow = Math.min(startRow, endRow);
	  const TLIdx = minRow * config.GRID_SIZE + minCol;
	  const maxRow = Math.max(startRow, endRow);
	  const memos = new Map();
	  const width = maxCol - minCol + 1;
	  const height = maxRow - minRow + 1;
	  const data = [];
	  for (let y = 0; y < height; y++) {
	      const rowData = new Uint8Array(width);
	      for (let x = 0; x < width; x++) {
		  const index = (minRow + y) * config.GRID_SIZE + (minCol + x);
		  rowData[x] = state.map[index];
		  if (state.memos.has(index)) {
		      memos.set(index, state.memos.get(index));
		  }
	      }
	      data.push(rowData);
	  }
	  state.clipboard = { data, memos, width, height, TLIdx };
	  showStatus(`${width}x${height} の範囲をコピーしました`);
	  // console.log("Copied to clipboard:", state.clipboard); // デバッグ用にコンソールに出力
      };
      /**
       * 指定した位置にクリップボードの内容を貼り付ける（ペーストする）関数
       * @param {number} TLIdx - 貼り付け先の左上インデックス
       */
      const pasteClipboard = (idx) => {
	  if (!state.clipboard.data) return;
	  const { data, memos, width, height } = state.clipboard;
	  const Col = idx % config.GRID_SIZE;
	  const Row = Math.floor(idx / config.GRID_SIZE);
	  if (state.sourceIndex !== null) {
	      const orgC = state.sourceIndex % config.GRID_SIZE;
	      const orgR = Math.floor(state.sourceIndex / config.GRID_SIZE);
	      for (let y = 0; y < height; y++) {
		  for (let x = 0; x < width; x++) {
		      const orgId = (orgR + y) * config.GRID_SIZE + (orgC + x);
		      handleCell(orgId, config.BASE_COLOR_INDEX);
		      // 移動元のメモを削除
		      if (state.memos.has(orgId)) {
			  state.memos.delete(orgId);
			  updateMemoOnCell(orgId, null);
		      }
		  }
	      }
	  }
	  // 新しい位置にメモを移動
	  memos.forEach((memoText, originalIndex) => {
	      const delta = originalIndex - state.sourceIndex;
	      const newIndex = idx + delta;
	      state.memos.set(newIndex, memoText);
	      updateMemoOnCell(newIndex, memoText);
	  });
	  for (let y = 0; y < height; y++) {
	      for (let x = 0; x < width; x++) {
		  const mapIdx = (Row + y) * config.GRID_SIZE + (Col + x);
                  handleCell(mapIdx, data[y][x]);
	      }
	  }
	  saveMap();
	  saveMemos();
	  showStatus(`${width}x${height} の範囲を移動しました`);
      };
      

      /**
       * 選択領域をクリアする関数
       */
      const clearSelection = () => {
	  document.querySelectorAll('.cell.selecting').forEach(c => c.classList.remove('selecting'));
	  state.isSelectionActive = false;
	  state.selectionStartIndex = null;
          state.clipboard = { data: null, memos: null, width: 0, height: 0, TLIdx: null };
      };
      const loadMemos = () => {
	  const memoString = localStorage.getItem(config.LOCAL_STORAGE_MEMO_KEY);
	  if (memoString) {
	      try {
		  state.memos = new Map(JSON.parse(memoString));
	      } catch (e) {
		  console.error("Failed to parse memos:", e);
		  state.memos = new Map();
	      }
	  }
      };
      const loadMap = () => {
	  const mapString = localStorage.getItem(config.LOCAL_STORAGE_MAP_KEY);
	  if (mapString && mapString.length === config.GRID_SIZE * config.GRID_SIZE) {
              for (let i = 0; i < state.map.length; i++) {
		  state.map[i] = parseInt(mapString[i], 16);
              }
              showStatus('Loaded Map form Your Browser(Local Strage ).', config.LOCAL_STORAGE_MAP_KEY);
	  } else {
              showStatus('Created New map.');
              state.map.fill(config.BASE_COLOR_INDEX);
	  }
	  loadMemos();
	  renderGrid();
	  ui.loadingOverlay.classList.add('is-hidden');
	  
      };
      
      const handleMouseDown = (e) => {
	  const cell = e.target.closest('.cell');

	  // 中ボタン、または左右同時押しでのパン操作開始
	  if (e.button === 1 || e.buttons === 3) {
	      e.preventDefault();
	      state.isPanning = true;
	      // パン操作では音を鳴らさない
	      state.panStart.x = e.clientX;
	      state.panStart.y = e.clientY;
	      
	      const currentTransform = new DOMMatrix(getComputedStyle(ui.mapContainer).transform);
	      state.initialTransform.x = currentTransform.m41;
	      state.initialTransform.y = currentTransform.m42;
	      
	      ui.mapContainer.style.cursor = 'grabbing';
	      return;
	  }

	  if (!cell || inPal) return;

	  // 選択領域外での左クリックで選択解除
	  if (state.isSelectionActive && !cell.classList.contains('selecting') && e.button === 0) {
              clearSelection();
	      playClick();
	  }

	  if (e.button === 0) { // 左クリック
	      if (e.shiftKey) { // Shift + 左クリックでメモ編集
		  e.preventDefault();
		  const i = parseInt(cell.dataset.idx, 10);
		  const currentMemo = state.memos.get(i) || '';
		  const newMemo = prompt('メモを入力してください:', currentMemo);

		  if (newMemo !== null) { // キャンセルされなかった場合
		      if (newMemo) {
			  state.memos.set(i, newMemo);
		      } else {
			  state.memos.delete(i);
		      }
		      updateMemoOnCell(i, newMemo);
		      saveMemos();
		      playClick();
		  }
	      } else if (cell.classList.contains('selecting')) {
		  // 選択領域内の左クリック: ドラッグ移動を開始
		  e.preventDefault();
		  state.isMovingSelection = true;
		  state.moveStartIndex = parseInt(cell.dataset.idx, 10);

		  // 移動元の左上インデックスを計算して保持
		  const selectedCells = document.querySelectorAll('.cell.selecting');
		  state.sourceIndex = Array.from(selectedCells).reduce((min, c) => Math.min(min, parseInt(c.dataset.idx, 10)), Infinity);
		  selectedCells.forEach(c => c.classList.add('grabbing'));
		  playClick();

              } else {
		  // 通常のセルクリック
		  state.isDrawing = true;
		  const i = parseInt(cell.dataset.idx, 10);
		  playClick();
		  handleCell(i);
              }
	  } else if (e.button === 2) { // 右クリック
              e.preventDefault();
              // 既存の選択をクリアして新しい選択を開始
              clearSelection();
              state.isSelecting = true;
              document.body.classList.add('is-selecting-rect');
              state.isSelectionActive = true;
              state.selectionStartIndex = parseInt(cell.dataset.idx, 10);
              updateSelectionHighlight(state.selectionStartIndex);
	      playClick();
	  }
      };

      const handleMouseOver = (e) => {
	  // パン中は他のマウスオーバー処理を中断
	  if (state.isPanning) {
	      // isPanningがtrueでも、ボタンが離されている場合があるためチェック
	      if (e.buttons !== 4 && e.buttons !== 3) { // 4=中ボタン, 3=左右ボタン
		  state.isPanning = false;
		  ui.mapContainer.style.cursor = '';
	      }
	  }
	  const cell = e.target.closest('.cell');
	  if (!cell) return;

	  if (state.isDrawing) { // 左ドラッグ描画中の処理
	      const i = parseInt(cell.dataset.idx, 10);
	      handleCell(i);
	  }
	  // メモのツールチップ表示
	  if (cell.classList.contains('has-memo')) {
	      const i = parseInt(cell.dataset.idx, 10);
	      const memoText = state.memos.get(i);
	      if (memoText) {
		  ui.tooltip.textContent = memoText;
		  ui.tooltip.style.display = 'block';
	      }
	  } else {
	      ui.tooltip.style.display = 'none';
	  }


	  if (state.isSelecting) { // 矩形選択中のハイライト更新
              const i = parseInt(cell.dataset.idx, 10);
              updateSelectionHighlight(i);
	  } else if (state.isMovingSelection) { // 選択領域の移動中のハイライト更新
	      const i = parseInt(cell.dataset.idx, 10);
	      const sRow = Math.floor(state.moveStartIndex / config.GRID_SIZE);
	      const sCol = state.moveStartIndex % config.GRID_SIZE;
	      const row = Math.floor(i / config.GRID_SIZE);
	      const col = i % config.GRID_SIZE;
	      const dRow = row - sRow;
	      const dCol = col - sCol;
	      const newTL = state.sourceIndex + dRow * config.GRID_SIZE + dCol;
	      drawSelHighLight(newTL, state.clipboard.width, state.clipboard.height);
	  }
      };

      const handleMouseUp = (e) => {
	  if (isDrag) {
	      isDrag = false; ui.paletteContainer.classList.remove('grabbing');
	  }
	  if (state.isPanning) {
	      state.isPanning = false;
	      ui.mapContainer.style.cursor = '';
	  }
	  if (state.isDrawing) {
	      state.isDrawing = false;
	      saveMap(); // 描画が終わったら保存
	      showStatus('マップを保存しました');
	  }
	  if (state.isMovingSelection) {
	      const cell = e.target.closest('.cell');
	      if (cell) {
		  const eIdx = parseInt(cell.dataset.idx, 10);
		  const sRow = Math.floor(state.moveStartIndex / config.GRID_SIZE);
		  const sCol = state.moveStartIndex % config.GRID_SIZE;
		  const eRow = Math.floor(eIdx / config.GRID_SIZE);
		  const eCol = eIdx % config.GRID_SIZE;
		  const dRow = eRow - sRow;
		  const dCol = eCol - sCol;
		  const pasteIdx = state.sourceIndex + dRow * config.GRID_SIZE + dCol;
		  pasteClipboard(pasteIdx); // 貼り付けを実行
		  clearSelection(); // 選択範囲とクリップボードをクリア
	      }
	      state.isMovingSelection = false;
	      state.moveStartIndex = null;
	      state.sourceIndex = null; // 移動元の情報をクリア
	  }
	  document.querySelectorAll('.cell.grabbing').forEach(c => c.classList.remove('grabbing'));
	  inPal = false;
	  if (state.isSelecting && e.button === 2) {          // 矩形選択の終了処理
	      const cell = e.target.closest('.cell');
	      if (cell) {
		  const endIdx = parseInt(cell.dataset.idx, 10);
		  copySelData(endIdx);
	      }
	      state.isSelecting = false;
	      document.body.classList.remove('is-selecting-rect');
	  }
      };
      
      const handleMouseMove = (e) => {
	  // パン操作中のマップ移動
	  if (state.isPanning) {
	      const dx = e.clientX - state.panStart.x;
	      const dy = e.clientY - state.panStart.y;
	      ui.mapContainer.style.transform = `translate(${state.initialTransform.x + dx}px, ${state.initialTransform.y + dy}px)`;
	      return;
	  }

	  // パレット移動
	  if (isDrag) {
	      let newX = e.clientX - dragOffX;
	      let newY = e.clientY - dragOffY;
	      const maxX = window.innerWidth - ui.paletteContainer.offsetWidth;
	      const maxY = window.innerHeight - ui.paletteContainer.offsetHeight;
	      newX = Math.max(0, Math.min(newX, maxX));
	      newY = Math.max(0, Math.min(newY, maxY));
	      ui.paletteContainer.style.left = `${newX}px`;
	      ui.paletteContainer.style.top = `${newY}px`;
	  }

	  // ツールチップの位置を更新
	  if (ui.tooltip.style.display === 'block') {
	      ui.tooltip.style.left = `${e.clientX + 15}px`;
	      ui.tooltip.style.top = `${e.clientY + 15}px`;
	  }
      };

      // 選択領域クリアボタンの処理
      document.getElementById('clr-sel').addEventListener('click', () => {
	  if (state.clipboard.TLIdx !== null) { // 選択範囲がある場合のみ実行
	      const { TLIdx, width, height } = state.clipboard;
	      const sCol = TLIdx % config.GRID_SIZE;
	      const sRow = Math.floor(TLIdx / config.GRID_SIZE);
	      for (let y = 0; y < height; y++) {
		  for (let x = 0; x < width; x++) {
		      handleCell((sRow + y) * config.GRID_SIZE + (sCol + x), config.BASE_COLOR_INDEX);
		  }
	      }
	      saveMap();
	      clearSelection();
	      playClick();
	  }
      });

      // 選択領域塗りつぶしボタンの処理
      document.getElementById('fill-sel').addEventListener('click', () => {
	  if (state.clipboard.TLIdx !== null) { // 選択範囲がある場合のみ実行
	      const { TLIdx, width, height } = state.clipboard;
	      const sCol = TLIdx % config.GRID_SIZE;
	      const sRow = Math.floor(TLIdx / config.GRID_SIZE);
	      for (let y = 0; y < height; y++) {
		  for (let x = 0; x < width; x++) {
		      handleCell((sRow + y) * config.GRID_SIZE + (sCol + x), state.selectedColor);
		  }
	      }
	      saveMap();
	      showStatus('選択範囲を塗りつぶしました');
	      playClick();
	  }
      });

      // --- エクスポート/インポート機能 ---
      const exportBtn = document.getElementById('export-btn');
      exportBtn.addEventListener('click', () => {
	  const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:T]/g, '');
	  const defaultFilename = `wiz-mapper-data_${timestamp}.json`;
	  const filename = prompt('ファイル名を入力してください:', defaultFilename);

	  if (filename) {
	      try {
		  const dataToExport = {
		      mapData: Array.from(state.map),
		      memoData: Array.from(state.memos.entries()),
		  };
		  const jsonString = JSON.stringify(dataToExport, null, 2);
		  const blob = new Blob([jsonString], { type: 'application/json' });
		  const url = URL.createObjectURL(blob);
		  const a = document.createElement('a');
		  a.href = url;
		  a.download = filename.endsWith('.json') ? filename : `${filename}.json`;
		  document.body.appendChild(a);
		  a.click();
		  document.body.removeChild(a);
		  URL.revokeObjectURL(url);
		  showStatus('データをファイルに保存しました');
	      } catch (error) {
		  console.error("Export failed:", error);
		  showStatus('エクスポート中にエラーが発生しました');
	      }
	      playClick();
	  }
      });

      const importBtn = document.getElementById('import-btn');
      importBtn.addEventListener('click', () => ui.importFileInput.click());
      ui.importFileInput.addEventListener('change', (event) => {
	  const file = event.target.files[0];
	  if (!file) return;
	  const reader = new FileReader();
	  reader.onload = (e) => {
	      try {
		  const data = JSON.parse(e.target.result);
		  if (data.mapData && data.mapData.length === config.GRID_SIZE * config.GRID_SIZE && data.memoData) {
		      state.map = new Uint8Array(data.mapData);
		      state.memos = new Map(data.memoData);
		      renderGrid();
		      saveMap();
		      saveMemos();
		      showStatus('ファイルからデータを読み込みました');
		  } else { throw new Error('Invalid data format'); }
	      } catch (error) { showStatus('ファイルの読み込みに失敗しました'); }
	  };
	  reader.readAsText(file);
	  ui.importFileInput.value = ''; // 同じファイルを再度選択できるようにリセット
	  playClick();
      });

      document.getElementById('help-btn').addEventListener('click', () => {
	  const helpText = `
Wiz Mapper - 基本操作ヘルプ
--------------------------------------------------
【描画】
・左クリック: 選択色で描画 / 再クリックで消去
・左ドラッグ: 連続で描画

【範囲選択】
・右ドラッグ: 範囲を選択
・選択範囲内を左ドラッグ: 範囲を移動

【メモ】
・Shift + 左クリック: メモの作成・編集

【画面操作】
・マウス中ボタンドラッグ: マップのスクロール
--------------------------------------------------`;
	  alert(helpText);
	  playClick();
      });

      const setupEventListeners = () => {
	  document.addEventListener('mouseup', handleMouseUp);
	  document.addEventListener('mousemove', handleMouseMove);
	  ui.mapContainer.addEventListener('mousedown', handleMouseDown);
	  ui.mapContainer.addEventListener('mouseover', handleMouseOver);
	  ui.mapContainer.addEventListener('contextmenu', (e) => e.preventDefault());

	  document.getElementById('reset-view-btn').addEventListener('click', () => {
	      ui.mapContainer.style.transform = 'translate(0px, 0px)';
	      state.initialTransform.x = 0;
	      state.initialTransform.y = 0;
	      showStatus('表示位置をリセットしました');
	      playClick();
	  });

	  document.getElementById('print-btn').addEventListener('click', () => {
	      showStatus('マップを画像に変換しています...');
	      html2canvas(ui.mapContainer, {
		  backgroundColor: getComputedStyle(document.body).backgroundColor
	      }).then(canvas => {
		  const printWindow = window.open('', '_blank');
		  printWindow.document.write(`
		      <!DOCTYPE html><html><head><title>マップの印刷</title></head>
		      <body style="margin:0;"><img src="${canvas.toDataURL('image/png')}" style="width:100%;"></body></html>
		  `);
		  printWindow.document.close();
		  printWindow.onload = () => { printWindow.print(); };
	      });
	  });

	  ui.clearMapBtn.addEventListener('click', () => {
	      if (confirm('\n ┌○┐\n │ ワ│ハ_ハ\n │ イ│ ﾟωﾟ )　　　　　　　マップとメモを全て消去します\n │ プ│ ／  | 　　　　　　　この操作は元に戻せません\n └○┘   (⌒)\n        し⌒  ￣\n')) {
		  state.map.fill(config.BASE_COLOR_INDEX);
		  state.memos.clear();
		  renderGrid();
		  saveMap();
		  saveMemos();
		  showStatus('マップとメモをリセットしました');
	      }
	      playClick();
	  });

	  ui.paletteContainer.addEventListener('mousedown', (e) => {
	      if (e.target.closest('button')) {
		  inPal = true;
		  e.stopPropagation();
		  return;
	      }
	      isDrag = true;
	      ui.paletteContainer.classList.add('grabbing');
	      const rect = ui.paletteContainer.getBoundingClientRect();
	      dragOffX = e.clientX - rect.left;
	      dragOffY = e.clientY - rect.top;
	      e.preventDefault();
	  });

	  window.addEventListener('resize', () => {
	      const rect = ui.paletteContainer.getBoundingClientRect();
	      let newX = rect.left;
	      let newY = rect.top;
	      const maxX = window.innerWidth - ui.paletteContainer.offsetWidth;
	      const maxY = window.innerHeight - ui.paletteContainer.offsetHeight;
	      newX = Math.max(0, Math.min(newX, maxX));
	      newY = Math.max(0, Math.min(newY, maxY));
	      ui.paletteContainer.style.left = `${newX}px`;
	      ui.paletteContainer.style.top = `${newY}px`;
	  });
      };

      /**
       * アプリケーションの初期化
       */
      const init = () => {
	  createPal();
	  loadMap(); // loadMap内でloadMemosが呼ばれるため、ここでは不要
	  setupEventListeners();
      };

      // --- 初期化処理の実行 ---
      init();


      // --- Picture-in-Picture 機能 ---
      const pipButton = document.getElementById('pip-btn');
      let pipWindow = null;

      pipButton.addEventListener('click', async () => {
	  if (!window.documentPictureInPicture) {
	      showStatus('お使いのブラウザはこの機能に未対応です');
	      return;
	  }
	  playClick();
	  try {
	      pipWindow = await window.documentPictureInPicture.requestWindow({
		  width: ui.mapContainer.clientWidth,
		  height: ui.mapContainer.clientHeight,
	      });

	      // PiPウィンドウにタイトルを設定
	      const pipTitle = document.createElement('title');
	      pipTitle.textContent = 'Wiz Mapper - Map View';
	      pipWindow.document.head.appendChild(pipTitle);

	      [...document.styleSheets].forEach((styleSheet) => {
		  const cssRules = [...styleSheet.cssRules].map((rule) => rule.cssText).join('');
		  const style = document.createElement('style');
		  style.textContent = cssRules;
		  pipWindow.document.head.appendChild(style);
	      });
	      pipWindow.document.body.append(ui.mapContainer);
	      pipWindow.document.addEventListener('mouseup', handleMouseUp);
	      pipWindow.document.addEventListener('mousemove', handleMouseMove);
	      pipWindow.addEventListener('pagehide', (event) => {
		  document.body.insertBefore(ui.mapContainer, ui.status);
		  pipWindow = null;
	      });
	  } catch (error) {
	      console.error('Picture-in-Picture Error:', error);
	  }
      });
    </script>
  </body>
</html>
